apiVersion: apps/v1
kind: StatefulSet
meta:
  name: postgres
  namespace: dualite
  labels:
    app: postgres
spec:
  serviceName: "postgres"
  replicas: 1
  selector:
    matchLabels:
      app: postgres
  template:
    meta:
      labels:
        app: postgres
    spec:
      containers:
      - name: postgres
        image: postgres:16
        ports:
        - containerPort: 5432
          name: postgres
        env:
        - name: POSTGRES_DB
          valueFrom:
            configMapKeyRef:
              name: dualite-config
              key: DB_NAME
        - name: POSTGRES_USER
          valueFrom:
            secretKeyRef:
              name: dualite-secrets
              key: DB_USER
        - name: POSTGRES_PASSWORD
          valueFrom:
            secretKeyRef:
              name: dualite-secrets
              key: DB_PASSWORD
        - name: PGDATA
          value: /var/lib/postgresql/data/pgdata
        volumeMounts:
        - name: postgres-storage
          mountPath: /var/lib/postgresql/data
        - name: init-script
          mountPath: /docker-entrypoint-initdb.d
        resources:
          requests:
            cpu: "250m"
            memory: "512Mi"
          limits:
            cpu: "1000m"
            memory: "1Gi"
        readinessProbe:
          exec:
            command: ["pg_isready", "-U", "$(POSTGRES_USER)"]
          initialDelaySeconds: 5
          periodSeconds: 10
        livenessProbe:
          exec:
            command: ["pg_isready", "-U", "$(POSTGRES_USER)"]
          initialDelaySeconds: 30
          periodSeconds: 15
      volumes:
      - name: init-script
        configMap:
          name: postgres-init-script
  volumeClaimTemplates:
  - meta:
      name: postgres-storage
    spec:
      accessModes: ["ReadWriteOnce"]
      resources:
        requests:
          storage: 10Gi
---
apiVersion: v1
kind: Service
meta:
  name: postgres-service
  namespace: dualite
  labels:
    app: postgres
spec:
  ports:
  - port: 5432
    targetPort: 5432
    name: postgres
  selector:
    app: postgres
  type: ClusterIP
---
apiVersion: v1
kind: ConfigMap
meta:
  name: postgres-init-script
  namespace: dualite
data:
  init.sql: |
    -- Create schema
    CREATE SCHEMA IF NOT EXISTS dualite;
    
    -- Create clients table
    CREATE TABLE IF NOT EXISTS dualite.clients (
        id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
        name VARCHAR(255) NOT NULL,
        email VARCHAR(255) NOT NULL,
        created_at TIMESTAMP NOT NULL DEFAULT NOW(),
        updated_at TIMESTAMP NOT NULL DEFAULT NOW(),
        is_active BOOLEAN NOT NULL DEFAULT TRUE,
        quota_limit INTEGER,
        quota_used INTEGER DEFAULT 0,
        subscription_level VARCHAR(50),
        meta JSONB
    );
    
    -- Create API keys table
    CREATE TABLE IF NOT EXISTS dualite.api_keys (
        id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
        client_id UUID NOT NULL REFERENCES dualite.clients(id),
        name VARCHAR(255) NOT NULL,
        key_hash VARCHAR(255) NOT NULL UNIQUE,
        created_at TIMESTAMP NOT NULL DEFAULT NOW(),
        last_used_at TIMESTAMP,
        expires_at TIMESTAMP,
        is_active BOOLEAN NOT NULL DEFAULT TRUE,
        permissions JSONB,
        CONSTRAINT fk_client FOREIGN KEY (client_id) REFERENCES dualite.clients(id) ON DELETE CASCADE
    );
    
    -- Create processing jobs table
    CREATE TABLE IF NOT EXISTS dualite.processing_jobs (
        id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
        client_id UUID NOT NULL REFERENCES dualite.clients(id),
        job_type VARCHAR(50) NOT NULL,
        status VARCHAR(50) NOT NULL DEFAULT 'pending',
        created_at TIMESTAMP NOT NULL DEFAULT NOW(),
        updated_at TIMESTAMP NOT NULL DEFAULT NOW(),
        completed_at TIMESTAMP,
        input_data JSONB,
        output_data JSONB,
        error_message TEXT,
        priority INTEGER DEFAULT 0,
        processing_time_ms INTEGER,
        meta JSONB,
        CONSTRAINT fk_client FOREIGN KEY (client_id) REFERENCES dualite.clients(id) ON DELETE CASCADE
    );
    
    -- Create invoice extractions table
    CREATE TABLE IF NOT EXISTS dualite.invoice_extractions (
        id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
        job_id UUID NOT NULL REFERENCES dualite.processing_jobs(id) ON DELETE CASCADE,
        invoice_number VARCHAR(100),
        invoice_date DATE,
        seller_name VARCHAR(255),
        seller_kvk VARCHAR(20),
        seller_iban VARCHAR(34),
        buyer_name VARCHAR(255),
        buyer_kvk VARCHAR(20),
        total_amount NUMERIC(15,2),
        vat_amount NUMERIC(15,2),
        vat_rate NUMERIC(5,2),
        currency VARCHAR(3) DEFAULT 'EUR',
        line_items JSONB,
        extracted_at TIMESTAMP NOT NULL DEFAULT NOW(),
        validation_status VARCHAR(50) DEFAULT 'pending',
        validation_messages JSONB,
        extracted_fields JSONB,
        confidence_scores JSONB
    );
    
    -- Create email extractions table
    CREATE TABLE IF NOT EXISTS dualite.email_extractions (
        id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
        job_id UUID NOT NULL REFERENCES dualite.processing_jobs(id) ON DELETE CASCADE,
        subject VARCHAR(500),
        sender_email VARCHAR(255),
        sender_name VARCHAR(255),
        recipient_emails JSONB,
        cc_emails JSONB,
        body_text TEXT,
        entities JSONB,
        intent VARCHAR(100),
        intent_confidence FLOAT,
        urgency_score FLOAT,
        effort_estimate VARCHAR(50),
        extracted_at TIMESTAMP NOT NULL DEFAULT NOW(),
        extracted_fields JSONB
    );
    
    -- Create rate limits table
    CREATE TABLE IF NOT EXISTS dualite.rate_limits (
        id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
        client_id UUID NOT NULL REFERENCES dualite.clients(id) ON DELETE CASCADE,
        endpoint VARCHAR(255) NOT NULL,
        requests_per_minute INTEGER NOT NULL DEFAULT 60,
        requests_per_hour INTEGER NOT NULL DEFAULT 1000,
        requests_per_day INTEGER NOT NULL DEFAULT 10000,
        created_at TIMESTAMP NOT NULL DEFAULT NOW(),
        updated_at TIMESTAMP NOT NULL DEFAULT NOW()
    );
    
    -- Create usage logs table
    CREATE TABLE IF NOT EXISTS dualite.usage_logs (
        id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
        client_id UUID NOT NULL REFERENCES dualite.clients(id) ON DELETE CASCADE,
        api_key_id UUID REFERENCES dualite.api_keys(id) ON DELETE SET NULL,
        endpoint VARCHAR(255) NOT NULL,
        method VARCHAR(10) NOT NULL,
        status_code INTEGER NOT NULL,
        request_size_bytes INTEGER,
        response_size_bytes INTEGER,
        processing_time_ms INTEGER,
        created_at TIMESTAMP NOT NULL DEFAULT NOW(),
        ip_address VARCHAR(45),
        user_agent TEXT
    );
    
    -- Create billing records table
    CREATE TABLE IF NOT EXISTS dualite.billing_records (
        id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
        client_id UUID NOT NULL REFERENCES dualite.clients(id) ON DELETE CASCADE,
        billing_period_start DATE NOT NULL,
        billing_period_end DATE NOT NULL,
        invoice_amount NUMERIC(10,2) NOT NULL,
        status VARCHAR(50) NOT NULL DEFAULT 'pending',
        created_at TIMESTAMP NOT NULL DEFAULT NOW(),
        updated_at TIMESTAMP NOT NULL DEFAULT NOW(),
        paid_at TIMESTAMP,
        details JSONB
    );
    
    -- Create indexes
    CREATE INDEX IF NOT EXISTS idx_jobs_client_id ON dualite.processing_jobs(client_id);
    CREATE INDEX IF NOT EXISTS idx_jobs_status ON dualite.processing_jobs(status);
    CREATE INDEX IF NOT EXISTS idx_api_keys_client_id ON dualite.api_keys(client_id);
    CREATE INDEX IF NOT EXISTS idx_invoice_extractions_job_id ON dualite.invoice_extractions(job_id);
    CREATE INDEX IF NOT EXISTS idx_email_extractions_job_id ON dualite.email_extractions(job_id);
    CREATE INDEX IF NOT EXISTS idx_usage_logs_client_id ON dualite.usage_logs(client_id);
    CREATE INDEX IF NOT EXISTS idx_usage_logs_created_at ON dualite.usage_logs(created_at);
    
    -- Create update timestamp triggers
    CREATE OR REPLACE FUNCTION update_timestamp()
    RETURNS TRIGGER AS $$
    BEGIN
        NEW.updated_at = NOW();
        RETURN NEW;
    END;
    $$ LANGUAGE plpgsql;
    
    CREATE TRIGGER update_clients_timestamp BEFORE UPDATE ON dualite.clients
    FOR EACH ROW EXECUTE PROCEDURE update_timestamp();
    
    CREATE TRIGGER update_api_keys_timestamp BEFORE UPDATE ON dualite.api_keys
    FOR EACH ROW EXECUTE PROCEDURE update_timestamp();
    
    CREATE TRIGGER update_processing_jobs_timestamp BEFORE UPDATE ON dualite.processing_jobs
    FOR EACH ROW EXECUTE PROCEDURE update_timestamp();
    
    CREATE TRIGGER update_rate_limits_timestamp BEFORE UPDATE ON dualite.rate_limits
    FOR EACH ROW EXECUTE PROCEDURE update_timestamp();
    
    CREATE TRIGGER update_billing_records_timestamp BEFORE UPDATE ON dualite.billing_records
    FOR EACH ROW EXECUTE PROCEDURE update_timestamp();
